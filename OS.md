## 운영체제란?

- 컴퓨터 시스템의 자원들을 효율적으로 관리하며 사용자가 컴퓨터를 편리하고 효과적x으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임이다.
- 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공한다.
- 종류: 윈도우, 유닉스, 리눅스 등
- 목적: 처리 능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축
- 기능
  1. 프로세서, 기억장치, 입출력장치, 파일 및 정보 자원 관리
  2. 자원 스케줄링 제공
  3. 사용자와 시스템간 인터페이스 제공
  4. 하드웨어와 네트워크 관리 및 제공
  5. 데이터 관리, 데이터와 자원의 공유 기능 제공
  6. 시스템 오류 검사 및 복구
  7. 자원 보호 기능 제공
  8. 입출력 보조 기능 제공

## 프로세스와 스레드?

※ 프로그램 : 파일이 저장 장치에 저장, 메모리에는 올라가 있지 않은 정적인 상태

- 프로세스 : 운영체제로부터 자원을 할당받은 작업의 단위

  : 다른 정의 - 동적 상태의 프로그램

  ![img](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a2620cb7-aae2-406f-9446-6fcde4b84f26/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210618%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210618T075156Z&X-Amz-Expires=86400&X-Amz-Signature=64c3643fb3ddc2b1d50a9250286efe8a8d6aec9a6b92ed2a5291ba152c891fbb&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

  특징

  - 메모리에 올라와 있는 프로그램의 인스턴스(독립적인 개체)

  - 프로세스는 각각 독립된 메모리 영역을 할당받는다.

    **메모리 영역**

    1. Code: 코드 자체를 구성하는 메모리 영역(프로그램 명령)
    2. Data: 전역 변수, 정적 변수, 배열 등(초기화된 데이터)
    3. Stack: 지역 변수, 매개변수, 리턴 값등(임시 메모리 영역)
    4. Heap: 동적 할당 시 사용(new(), mallock() 등)

  - 프로세스 하나당 최소 한개의 스레드(메인 스레드)를 가지고 있다.

  - 각 프로세스는 별도의 주소 공간에서 실행되며, 다른 프로세스의 변수나 자료구조에 접근할 수 없다.

  - 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신 (IPC:inter-process communication) 이용

    ex) 파일, 파이프, 소켓

  **멀티 프로세스**

  : 하나의 응용 프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 한다.

  - 장점
    1. 여러개의 자식 프로세스 중 하나에 문제가 발생하면 해당 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않는다.
  - 단점
    1. 각각의 독립된 메모리 영역을 할당받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수 공유가 안된다.
    2. Context switching 에서의 오버헤드(캐쉬메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모)가 발생한다.

- 스레드 : 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위

  : 프로세스의 한계(자신에게 할당된 메모리에만 접근 제약)를 해결하기 위해 만들어진 개념

  ![img](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/3576d7e8-e8ee-4859-ab7b-6764bd1b61ea/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210618%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210618T075214Z&X-Amz-Expires=86400&X-Amz-Signature=c42e9ebabcc11338dbd04dd96e900feb1ae42b84c02c08db2dbedbe8f4e8969a&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

  특징

  - 프로세스의 자원을 공유한다.
  - 스레드 간 메모리를 공유(code/data/heap)하며 작동한다.
  - 하나의 스레드가 오류나면 전체 프로세스가 종료된다.
  - ex) 알고리즘 coding 느낌

  멀티스레드 특징

  - 장점
    1. Context-Switching할 때 공유하고 있는 메모리만큼의 메모리 자원을 아낄 수 있다.
       - 만약 CPU의 코어 수 보다 더 많은 스레드가 실행되면, 각 코어가 여러 작업을 번갈아 가며 수행하게 되며 이때 각 스레드가 교체될때 스레드간의 context-switching이 발생한다.
       - 이러한 context-switching에 걸리는 시간이 커지면 멀티 스레딩의 효율이 떨어짐.
       - 따라서 단순한 계산은 싱글 스레드로 동작하는 것이 더 효율적일 수 있다.
    2. 스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 스레드간 통신의 부담이 적어서 응답 시간이 빠르다.
  - 단점
    1. 스레드 하나가 프로세스 내 자원을 망쳐버린다면 프로세스가 종료될 수 있다.
    2. 자원을 공유하기 때문에 필연적으로 동기화 문제가 발생할 수밖에 없다.

# CPU

- Central Processing Unit의 줄임말로 중앙 처리 장치라고 한다.
- 컴퓨터와 다른 부품들과 신호를 주고 받으면서 시스템 전체를 제어하는 역할을 한다. (**사용자와 소통하는 역할을 한다**)

※ 이해하기 쉽게 컴퓨터 구매할때 확인하는 정보로 알아보자.

![https://blog.kakaocdn.net/dn/bOpXFQ/btq65dGhRUz/KcIX5wT5o3ksT49HkNiwp1/img.png](https://blog.kakaocdn.net/dn/bOpXFQ/btq65dGhRUz/KcIX5wT5o3ksT49HkNiwp1/img.png)

1. 코어 : CPU 핵심, 이진수 연산, 1개면 싱글코어, 여러개면 멀티코어(듀얼, 쿼드, 헥사...)

> > 코어가 많다(=터널을 많이 뚫었다 = 처리 속도가 빠르다) ↔ 쓰레드가 많다(= 차선이 많다)

1. 클럭 : 초당 명령어를 처리할 수 있는 속도, GHz

> > 클럭이 높다(=제한속도가 높다 = 더 빠르게 일들을 처리할 수 있다)

1. L3 캐시 메모리 : RAM을 거치지 않고 즉각 응답할 수 있도록 저장하는 장소
2. 연산체계 : 32/64bit, 연산 능력, 2의 64승까지 연산 가능

- 구성 요소
  1. 제어 장치(CU): 컴퓨터에 있는 모든 장치들의 동작을 지시하고 제어하는 장치이다. 명령 레지스터에서 읽어들인 명령어를 해독하여 해당하는 장치에게 제어 신호를 보내 정확하게 수행하도록 지시한다.
  2. 연산 장치(ALU): 제어 장치의 명령에 따라 실제로 연산을 수행하는 장치(산술 연산, 논리 연산, 관계 연산 등)
  3. 레지스터: CPU 내부에서 처리할 명령어나 연산의 중간 결과 값 등을 일시적으로 기억하는 임시 기억장소이다.
  4. 버스: CPU, 메모리 I/O 장치 등과 상호 필요한 정보를 교환하기 위해 연결된 공동의 전송선이다.

# 컨택스트 스위칭

> CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정이다. 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태(Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말한다.

- Context: CPU가 해당 프로세스를 실행하기 위한 해당 프로세스의 정보들 (PCB에 저장)

- PCB: 프로세스 식별자, 프로세스 상태, 프로그램 카운터(다음에 실행할 명령어 주소), CPU 레지스터 및 일반 레지스터, CPU 스케쥴링 등등

  ![img](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/04d48687-b3af-4780-b9f0-a8494bbcb909/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210618%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210618T075242Z&X-Amz-Expires=86400&X-Amz-Signature=98abee81d108d72b1908449152e9f859329bc1b34c92a497951c8d2987593f8b&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

- Context Switching 필요 이유: 하나의 작업이 끝날 때까지 기다리면 속도가 너무 느리고 사용하기 불편해서

- 진행 과정:

  1. 대부분의 정보는 레지스터에 저장되고 PCB로 관리한다.
  2. 현재 실행하고 있는 작업의 PCB 정보를 저장한다.
  3. 다음 실행할 작업의 PCB 정보를 읽어 레지스터에 저장하고 CPU가 이전에 진행했던 과정을 연속적으로 수행한다.

- 주의할 점: Context Switching 일 때 해당 CPU는 아무 일을 할 수 없어서 오버헤드가 발생한다.

- Dispatcher는 현재 CPU 데이터는 이전 프로세스의 PCB에 갱신하고, 새로 시작되는 프로세스의 PCB 데이터를 CPU로 복원해준다. Context switching이 발생할 때마다, dispatcher에서 수행하는 작업을 매번 수행해야하며 이 모든 것은 overhead이다.

- 입출력 요청이 왔을 때, CPU 사용 시간이 만료되었을 때, 자식 프로세스를 만들 때, 인터럽트 처리를 기다릴 때 발생한다.

# 스케쥴링

> 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업을 의미.

**목표**

- 공정한 스케쥴링
- 처리량의 극대화(Batch System), 시간보단 처리량이 중요하다
- 응답시간 최소화(Interactive System)
- 균형있는 자원 활용
- 반환시간 예측(Real-time System)

**비선점 스케쥴링**

비선점(nonpreemptive): 프로세스 종료 or I/O 이벤트가 있을때까지 실행 보장(처리시간 예측이 어렵다)

1. FCFS(First Come First Server)
   - 큐에 도착한 순서대로 CPU 할당
   - 실행시간이 짧은게 뒤로 가면 평균 대기시간이 길어진다. (호위 효과)
2. SJF(shortest Job First)
   - 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행
   - FCFS 보다 평균 대기 시간 감소, 짧은 작업에 유리하다.
   - 기아 현상 발생 : 긴 수행시간을 가지는 프로세스는 계속 기다린다.

**선점 스케줄링**

선점(preemptive): 우선순위 높은게 CPU의 사용권을 선점할 수 있는 경우 (운영체제가 컨트롤한다)

1. Priority Scheduling
   - 우선 순위를 부여하여 우선순위가 높은 순서대로 처리
   - 에이징 기법으로 기아 현상은 해결할 수 있다.
2. Round Robin
   - FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 Time Quantum(실행시간의 최소 단위시간)만큼 CPU를 할당 받음
   - 할당 시간(time quantum)이 크면 FCFS와 같게 되고, 작으면 문맥 교환 (Context Switching) 잦아져서 오버헤드 증가
3. Multilevel-Queue(다단계 큐)
   - 작업들을 여러 개의 그룹으로 나누어 여러 개의 큐를 사용하는 기법
   - 우선 순위가 낮은 큐들이 실행 못하는 걸 방지하고자 우선 순위가 높은 큐에는 작은 할당 시간(time quantum)을 주고, 우선 순위가 낮은 큐에는 높은 할당 시간(time quantum)을 준다
4. Multilevel-Feedback-Queue(다단계 피드백 큐)
   - 다단계 큐에서 자신의 할당 시간을 다 채운 프로세스는 밑으로 내려가고 자신의 할당 시간을 다 채우지 못한 프로세스는 원래 큐 그대로 둔다.
   - 짧은 작업에 유리하며 입출력 작업에 우선권을 준다.
5. 대부분의 상용 운영체제는 여러 개의 큐를 사용하고 각 큐마다 다른 스케줄링 방식을 사용한다. 프로세스의 성격에 맞는 스케줄링 방식을 사용하여 최대한 효율을 높일 수 있는 방법을 선택한다.

**CPU 스케줄링 척도**

- Response Time: 작업이 처음 실행되기까지 걸린 시간
- Turnaround Time: 실행 시간과 대기 시간을 모두 합한 시간으로 작업이 완료될 때 까지 걸린 시간
- Waiting Time: 대기 큐에서의 대기시간
- Throughput: 단위시간당 완료된 프로세스 수
- CPU 이용률: CPU를 이용한 수치와 백분율

# 동기화

※ 동기화 이유?

- 덮어씌우기 문제

다중 처리에 의한 문제들이 발생한다. 공유 메모리를 사용하여 문제가 발생한다.

> > **병렬성, 협력성**

나중에 실행된 결과가 나중에 실행된 결과를 덮어씌우게 된다.

- 비일관성

경쟁 상태 : 실행 결과가 실행 과정(순서, 입력 타이밍, 시간)에 의존 하는 상황, 결과가 일정하지 않다.

> > **시스템의 일관성**이 무너지게 된다.

1. 동기화란 공유하는 자원의 일관성을 유지하는 것이다. 하나의 공유된 자원에 접근하려고 할 때 순서를 정하여 데이터의 일관성을 유지시킨다.
   - 데이터의 무결성
     - 일관성 -  원인과 결과가 보장되어 변하지 않는 것을 의미함
     - 정확성 - 중복이나 누락이 없는 상태
2. 임계구역 `Critical section`
   - 공유하는 데이터를 변경하는 코드 영역
   - 임계구역을 해결하기 위한 조건
     - 상호베타(Mutual Exclusion) - 오직 한 스레드만 진입 가능
     - 진행(Progress) - 한 임계구역에 접근하는 스레드를 결정하는 것은 유한시간 내에 이루어져야 함
     - 유한대기(Bounded Waiting) - 임계구역으로 진입하기 위해 대기하는 모든 스레드는 유한 시간 내에 해당 임계구역으로 진입할 수 있어야 함
3. 뮤텍스
   - 자원에 대한 접근을 동기화하기 위해 사용되는 `상호배제` 기술
   - 뮤텍스는 Locking 메커니즘으로 오직 하나의 쓰레드만이 동일한 시점에 뮤텍스를 얻어 임계 영역(Critical Section)에 들어올 수 있다. 그리고 오직 이 쓰레드만이 임계 영역에서 나갈 때 뮤텍스를 해제할 수 있다.
4. 세마포어
   - 운영체제에서 공유 자원에 대한 접속을 제어하기 위해 사용됨
   - 공유자원에 접근할 수 있는 최대 허용치만큼만 동시에 접근 가능.
   - 프로세스의 실행 순서를 원하는 순서로 설정할 수있다.
   - 버퍼가 가득 찼는지 비어있는지 확인하는 무한 반복문인 Busy Waiting을 해결할 수 있다.
   - 세마포어의 카운트가 0보다 작거나 같아져 동기화가 실행된 상황에, 다른 쓰레드가 signal 함수를 호출하면 세마포어의 카운트가 1증가하고, 해당 쓰레드는 락에서 나올 수 있다.
   - Counting Semaphore - 세마포어의 카운트가 양의 정수값을 가지며, 설정한 값만큼 쓰레드를 허용하고 그 이상의 쓰레드가 자원에 접근하면 락이 실행됨
   - Binary Semaphore - 세마포어의 카운트가 1이며 Mutex처럼 사용될 수 있다. (뮤텍스는 절대로 세마포어처럼 사용될 수 없다)
5. 교착상태 `DeadLock`
   - 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태입니다.
   - `상호배제` : 한 프로세스가 자원을 사용하면 다른 프로세스는 이 자원을 사용할 수 없다.
   - `점유대기` : 한 프로세스가 자원을 가지고 있는 상태에서 대기한다
   - `비선점` : 한 프로세스가 자원을 수행하는 중에는 다른 프로세스가 중간에 끼어들 수 없다.
   - `순환대기` : 프로세스가 요구하는 자원의 방향이 원형을 이룬다.
   - 해결방법
     - 예방 : 네 가지 중 최소 한 가지를 만족시키지 않는 것
     - 회피 : 교착상태를 자원 요청에 대한 잘못된 승인으로 판단한다.
     - 무시 : 네가지를 모두 만족하더라도 교착상태가 일어나기 희박하므로 조치하지 않음
     - 발견 : 주기적으로 교착상태가 발생했는지 검사, 오버헤드 발생
     - 회복 : 데드락이 일어날 때까지 기다리고 일어나면 순환하고 찾고 죽일 프로세스를 정하고 죽이던지 롤백



## 메모리 계층

![img](https://t1.daumcdn.net/cfile/tistory/996B92345BE2467F31)

> 메모리를 필요에 따라 여러가지 종류로 나누어 둠을 의미한다. 이때 필요한 대부분의 경우 CPU가 메모리에 더  빨리 접근하기 위함이다.

1. Register - CPU 내부
   - 로드-스토어 설계 : 메인 메모리에서 레지스터로 데이터 옮겨와 처리 후, 다시 메인 메모리로 저장
   - 최대 처리 용량 : CPU 처리 용량 - 32bit/64bit
   - 데이터와 명령어를 저장하는 역할, 가장 빠른 속도로 접근이 가능하다.
2. Cache - CPU 내부
   - 구분
     - Instruction Cache : 명령어 저장
     - Data Cache : 데이터를 저장
   - 지역성을 활용한다.
   - 지역성
     1. 시간적 지역성 : 최근 액세스 된 기억 장소가 가까운 미래에 다시 액세스 가능성 높음
     2. 공간적 지역성 : 액세스된 기억장소와 인접한 기억장소가 액세스될 가능성 높음
     3. 순차적 지역성 : 분기가 발생하지 않는 한, 명령어들은 기억장체에 저장된 순서대로 인출되어 실행되는 특성
3. Ram - CPU 외부
   - 메인메모리를 보통 RAM이라 하지만 같은 개념은 아니다. (보통 메인 메모리를 RAM, DRAM 사용할 뿐)
4. 하드 디스크 - CPU 외부
   - 외부 저장 장치 : SSD, HDD, 등



## 외부단편화, 내부단편화

#### 단편화

> 기억 장치의 빈 공간 또는 자료가 여러 개의 조각으로 나뉘는 현상

: RAM에서 작은 공간으로 남아 사용 가능한 메모리가 충분히 있지만 할당이 불가능한 상태

1. 내부 단편화
   - 정의 : 메모리 할당시, 필요한 양보다 더 큰 메모리가 할당되어 메모리 공간이 낭비되는 현상
2. 외부 단편화
   - 정의 : 빈 메모리가 서로 떨어져 존재할 때(할당, 해제 작업 반복에 의한), 총 메모리는 충분하지만 실제로 할당할 수 없는 현상



#### 페이징기법/세그멘테이션 기법



![10. 가상메모리 – 할당(페이징기법, 세그멘테이션기법 비교) : 네이버 블로그](https://mblogthumb-phinf.pstatic.net/MjAyMDAxMjhfMTUx/MDAxNTgwMTUyMTgzMDE1.cKL8rh0owjYNP4lQK-B5xmmmrbetfmyxIwng7yjNu0Ig.CNBKxWkdiYyszwaTG06eSWWquJFrB6l-m0-HzofbUXkg.PNG.dilector/01.png?type=w800)

1. 페이징 기법
   - 가상 메모리를 크기가 일정한 블록으로 나눈다.(PAGE)
   - 물리 메모리도 같은 크기의 블록으로 나누어 (프레임) 각각을 할당한다.
   - 고정된 크기의 프레임을 사용하므로 전부 사용되지 않으면 내부 단편화가 발생한다.
   
2. 세그멘테이션 기법

   - 페이징은 프로세스를 물리적으로 일정한 크기로 나눠서 메모리에 할당하였다. 반면에 세그먼테이션은 프로세스를 논리적 내용(code, data, stack)을 기반으로 나눠서 메모리에 배치하는 것을 말한다.

   - 가상 메모리를 일정한 크기가 아니라 메모리에 따라 크기가 다른 세그먼트로 분할한다.
   - 각 크기에 맞는 물리 메모리 공간에 맞추어 할당한다.
   - 할당/제거가 반복되면 빈 공간들이 발생하여 외부 단편화가 발생한다.

## 가상 메모리, 요구페이지

#### 가상 메모리

> 프로세스 전체가 메모리 내에 올라오지 않더라도  실행 가능하도록 하는 기법, 가상 메모리는 물리 메모리부터 사용자 관점의 논리 메모리를 분리시켜 주 메모리를 균일한 크기의 저장 공간으로 구성된 엄청나게 큰 배열로 추상화 시켜준다.

- 현재 사용하지 않은 데이터를 빼내어 가상 메모리에 저장해두고, 실제 메모리에선 처리만 하게 하는 것이 가상 메모리의 역할이다. **요구 페이징 기법과 스와핑**으로 구현.

- CPU가 특정 프로세스의 어떤 공간을 참조할 때는 우선 가상 주소를 먼저 참조하고, 가상 주소에 해당하는 실제 물리 주소를 참조하게 된다.
  가상 주소를 참조할 때마다 매번 이를 물리 주소로 변환을 하게 되니까 이 시간을 짧게 하려고 **MMU**라는 하드웨어 칩의 지원을 받는다. MMU는 가상 주소를 물리 주소로 빠르게 변환해주는 역할을 한다.

  > **MMU** (Memory Management Unit):
  > CPU에 코드 실행 시, 가상 주소 메모리 접근이 필요할 때 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치.

- 장점

  - 사용자 프로그램이 물리 메모리보다 커져도 된다.
  - 각 사용자  프로그램이 더 작은 메모리를 차지하므로 더 많은 프로그램을 동시에 수행할 수 있다.
  - 프로그램을 메모리에 올리고 스왑하는데 필요한 입/출력 횟수가 줄어든다.
  - 가상메모리 파일의 공유를 쉽게 해주고 공유 메모리 구현을 가능하게 한다.
  - 프로세스 생성을 효율적으로 처리할 수 있는 메커니즘도 제공한다.

- 단점

  - 구현이 어렵고, 잘못 사용 시 성능이 현저히 저하 될 수 있다.

#### 요구 페이징

> 프로세스의 이미지를 Backing Store에 저장한다. Backing Store는 swap device로 하드웨어의 부분인데 페이지를 임시로 보관하는 공간이다. 프로세스는 페이지의 조합이기 때문에 필요한 페이지만 메모리에 올린다.

- 페이징 기법을 사용 할 때 페이지 테이블을 작성한다. MMU의 재배치 레지스터를 통해 논리 주소를 물리 주소로 바꾸어주는 주소 변환 과정을 거쳐 CPU가 프로세스는 연속적으로 할당 되어져 있다고 속게 만드는 작업을 한다. 이걸 요구 페이징 기법을 사용하면 페이지가 메모리에 올라와있는 것도 있고 올라가지 않는 Backing Store에 보관되어 있는 것도 존재한다. 그래서 페이지 테이블을 작성할 때 이를 구분해 줄 도구로 유효한 비트 필드를 페이지 테이블에 추가해서 0과 1로 메모리에 저장되어 있는지 없는지 구분할 수 있다.
- 유효한 비트 필드를 통해 CPU에서 해당 메모리를 가져오라고 논리 주소를 보냈는데 페이지 테이블에서 접근하려는 페이지가 메모리에 있는지 없는지 알 수 있다.
- 페이지 부재 : 페이지가 있다면 Backing Store에서 해당 페이지를 가져온다. 이걸 수행하려면 CPU는 하던 작업을 멈추고 운영체제가 나서서 Backing Store를 뒤져 필요한 페이지를 메모리에 저장하고 유효한 비트 필드를 바꿔준다. 이런 현상을 페이지 부재라고 한다.
- 종류
  - 순수 요구 페이징 : 처음부터 모든 페이지를 적재시키지 않고 CPU가 요구할 때 유효 비트를 바꿔서 페이지를 저장하는 방법, 페이지를 요구할 때만 메모리에 저장하므로 메모리의 낭비는 줄일 수 있다. 하지만 요구에 의해 앞선 페이지 부재의 현상을 처리하려고 하면 많은 부담이 발생한다.
  - 프리페이징 : 우선 필요한 것 같은 페이지를 저장시키고 필요할 때 다른 페이지를 저장시키는 방법, 처리하는 속도는 빠르지만 메모리 낭비가 될 수 있다.
- 요구페이징은 현재 필요한 페이지만 메모리에 올리는 방식. 필요한 페이지가 메모리에 없다면 인터럽트 신호를 발생하여 디스크 내부에 있는 페이지를 메모리에 할당하는 작업을 한다. 가상 메모리와 같은 용어로 사용하는 경우가 많다. Swapping와 Demanding Paging의 공통점은 둘 다 메모리와 backing store(보조 기억) 사이를 서로 오고 가는 기능을 수행하지만, Swapping은 프로세스 단위로 이동하고 Demanding Paging은 페이지 단위로 이동하는 차이점이 있다.

## 파일

> CPU, 주기억장치 다음 중요한 컴퓨터 시스템 자원은 하드디스크와 같은 보조기억장치이다. 하드디스크가 데이터를 관리하는 방식은 파일 시스템이다. sector는 여러 개로 묶어서 사용한다고 했는데, 이를 블록(block)이라 한다. 하드디스크는 블록 단위로 읽고 쓰기 때문에 block device 라고 불리기도 한다.

- platter: 실제 데이터를 기록하는 자성을 가진 원판이다. platter는 그림과 같이 여러 개가 존재하고 앞뒤로 사용할 수 있다. 한 platter는 여러 개의 track으로 이루어져 있다.
- track: platter의 동심원을 이루는 하나의 영역이다.
- sector: 하나의 track을 여러 개로 나눈 영역을 sector라 한다. sector size는 일반적으로 512 bytes이며 주로 여러 개를 묶어서 사용한다.
- cylinder: 한 cylinder는 모든 platter에서 같은 track 위치의 집합을 말한다.

## 디스크 스케줄링

> 여러 프로세스가 동시에 디스크를 읽으려는 요청이 올 수 있다. 이와 같은 요청이 오면 디스크 역시 CPU와 같이 디스크 큐(dist queue)에서 요청을 저장해두고 이를 처리해야 한다. 디스크를 읽는 시간은 매우 오래 걸리는 작업이고 특히 탐색 시간이 오래걸리므로 최대한 이 시간을 줄이는 것이 중요하다. 이러한 방법들을 디스크 스케줄링 알고리즘이라 한다.

- FCFS
- SSTF (Shortest-Seek-Time-First) : 현재 헤드가 다음 요청을 처리하기 위해 움직여야 하는 거리가 가장 짧은 것을 선택
- Scan : 헤드가 지속적으로 디스크를 앞뒤로 검사하는 것이다. 그래서 헤드가 앞으로 스캔할 때(번호가 작은 실린더 방향)와 뒤로 스캔할 때(번호가 큰 실린더 방향) 선택하는 실린더가 서로 다르다.
- Circular Scan : 한 방향으로 계속 움직이는 것이 마치 원형으로 움직인 것과 같은 모습이다. 움직이는 거리는 더 길어질 수 있지만 다시 처음 위치로 되돌아갈 때는 데이터를 읽지 않으므로 더 빠른 속도로 움직일 수 있다
- Look : 존재하는 실린더의 최소와 최대 범위만 움직이는 알고리즘을 Look 스케줄링 알고리즘이라고 한다. 하지만 이 범위를 알기 위해서 미리 큐를 검사해야한다.
- Circular Look





----------------------------------------------------------------------------아래 사항 업로드 ---------------

### ★ CPU

\- Central Processing Unit의 줄임말로 중앙 처리 장치라고 한다.

\- 컴퓨터와 다른 부품들과 신호를 주고 받으면서 시스템 전체를 제어하는 역할을 한다. (**사용자와 소통하는 역할을 한다**)

 

이해하기 쉽게 컴퓨터 구매할때 확인하는 정보로 알아보자.



![img](https://blog.kakaocdn.net/dn/bOpXFQ/btq65dGhRUz/KcIX5wT5o3ksT49HkNiwp1/img.png)



\1. 코어? : CPU 핵심, 이진수 연산, 1개면 싱글코어, 여러개면 멀티코어(듀얼, 쿼드, 헥사...),

  \>> 코어가 많다(=터널을 많이 뚫었다 = 처리 속도가 빠르다) ↔ 쓰레드가 많다(= 차선이 많다)

\2. 클럭? : 초당 명령어를 처리할 수 있는 속도, GHz

  \>> 클럭이 높다(=제한속도가 높다 = 더 빠르게 일들을 처리할 수 있다)

\3. L3 캐시 메모리 : L = Level을 의미한다, RAM을 거치지 않고 즉각 응답할 수 있도록 저장하는 장소

\4. 연산체계 : 32/64bit, 연산 능력, 2의 64승까지 연산 가능

 

### ★ CPU scheduling

프로세스가 많아지면 프로세스에 순서를 정해줘야한다.

주체 : 운영체제가 기본적으로 한다.

\- 디스패치(dispatch) : 운영체제가 프로세스를 프로세서에 할당하는 작업 (Ready -> Running)

 : CPU scheduling 요소에 반드시 포함된다.

 : 작업 중 context switching이 발생할 수 있다.

CPU 실행 시간 + 입/출력 대기 시간 = 프로세스 실행 시간

\- 스케쥴리 기준 요소

 \1. CPU 사용 : 사용률이 40~60%인 프로세스가 적합하다.

 \2. 처리량 : 단위 시간 당 실행 완료된 프로세스 수

 \3. 총 처리 시간 : 대기 시간 + 프로세스 실행 시간(CPU 실행 시간 + 입출력 대기 시간)

 \4. 최적화된 시간은 평균 측정 시간으로 가정한다.

 

\- 선점 / 비선점 방식

 \1. 선점 방식 : 운영체제가 관리한다, 중간에 다른 프로세스 실행 가능(인터럽트에 의해), 최신 운영체제 스케쥴링 방식

 \2. 비선점 방식 : 프로세스가 끝나면 다음 프로세스가 실행된다.

 

\- FCFS (First Come First Served) - 비선점

 : CPU 요청이 빠른 프로세스를 우선 할당하는 방식 (Queue 사용)

 : 문제 - 호위 효과(Convoy Effect) 발생 : 수행 시간이 긴 프로세스가 점령하게 된다.

 

\- SJF (Shortest Job First) - 비선점

 : 수행 시간이 짧은 프로세스를 우선 할당하는 방식

 : 문제 - 기아 현상 발생 : 긴 수행시간을 가지는 프로세스가 오래 기다리게 된다.

 

\- SRTF (Shortest Remaining Time First) - 선점

 : 남은 수행 시간이 짧은 순서에 따라 할당하는 방식

 : 문제 - 계산 과정이 까다롭다

 

\- RR (Round Robin) - 선점

 : 시간 할당을 위한 할당량이 존재한다( 할당량 만큼만 작업하는 분할 시스템)

 

\- Priority - 선점, 비선점

 : 특정 기준으로 우선순위를 주고 스케쥴링하는 방식

 : 에이징 기법을 통해 기아 현상 해결 가능

 

\- 다단계 큐/ 다단계 피드백 큐

 : 여러 개의 큐를 이용하는 방식

 

### ★ Context Switching

**멀티프로세스 환경**에서 어떤 프로세스를 **실행하고 있는 상태**에서 다른 요청으로 **다른 프로세스가 실행되야 할 때**(우선순위에 의해) 기존 프로세스를 저장하고 다른 프로세스를 **수행하도록 교체하는 작업**을 의미한다.

 \- Context? : 사용자간, 사용자-시스템, 사용자-디바이스간 상호작용에 미치는 프로세스의 현재 상태를 규정하는 정보

 \- Context는 PCB(Process Control Block)에 저장된다. (프로세스 상태, 다음 주소, 레지스터 등)



![img](https://blog.kakaocdn.net/dn/baZicZ/btq67RvGGyf/m0O4m5sgDBqLyboSKVVV61/img.png)



 \- Context Switching 중에는 CPU를 사용하기 때문에 잦으면 오버헤드가 발생한다.

 

인터럽트(다른 프로세스가 실행되도록 인터럽트가 요청함)

 : CPU가 프로그램을 실행하고 있을 때 예외 상황이 발생하여 처리가 필요한 경우 CPU에게 요청하는 것

 \- 우선순위 : 라운드로빈 스케줄링 - 시간단위로 CPU에 할당하는 방식, 누가? OS 스케줄러가 한다.

즉, OS 스케줄러가 Context Switching을 한다.

 

 

### ★ 동기화

\1. 덮어씌우기 문제

다중 처리에 의한 문제들이 발생한다. 공유 메모리를 사용하여 영향을 주게 된다.

\>> **병렬성, 협력성**

나중에 실행된 결과가 나중에 실행된 결과를 덮어씌우게 된다.

 

\2. 비일관성

경쟁 상태 : 실행 결과가 실행 과정(순서, 입력 타이밍, 시간)에 의존 하는 상황, 결과가 일정하지 않다.

먼소리야? >> 

**시스템의 일관성**이 무너지게 된다.

 

임계 영역

 : 위 문제를 해결하기 위해 공유 자원을 선행 작업이 끝날때까지 사용할 수 없도록 하는 '작업 순서 강제 방법'

 : 하나의 작업만 임계 영역에 접근하여 작업하도록 강제한다.

 \- 구성

 \1. 진입 영역 : 임계 영역으로의 접근 허가를 받는 지점

 \2. 임계 영역 : 공유 자원을 사용하는 지점

 \3. 퇴출 영역 : 접근 허가를 반납하는 지점

 \4. 나머지 영역

 \- 요구 조건

 \1. 상호 배제 : 최대한 하나의 작업만 임계 영역에 접근할 수 있어야 한다.

 \2. 진행 : 진입 영역에 있는 작업들만 임계영역에 접근할 기회를 얻을 수 있어야 한다.

 \3. 한정된 대기 : 임계 영역 내 작업이 기아 상태가 되서는 안된다.

 

 \- 구현법

 \1. 세마포를 이용한 해결안

   : **공유 자원의 개수**로 카운팅하여 해결한다. (0이 되면 접근 제한, +,-1을 하며 제어한다)

 \2. 이진 세마포 (뮤텍스 : 상호 배제)

   : locking 메커니즘 활용 (lock을 가졌을 때만 접근 가능, 이후 반환)

 

세마포 vs 뮤텍스

세마포 : 여러개 방, 여러개의 열쇠, 제한된 방 갯수

뮤텍스 : 하나의 방, 하나의 열쇠, 열쇠 건네받아야 입장 가능
