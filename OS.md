## 운영체제란?

- 컴퓨터 시스템의 자원들을 효율적으로 관리하며 사용자가 컴퓨터를 편리하고 효과적x으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임이다.
- 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공한다.
- 종류: 윈도우, 유닉스, 리눅스 등
- 목적: 처리 능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축
- 기능
  1. 프로세서, 기억장치, 입출력장치, 파일 및 정보 자원 관리
  2. 자원 스케줄링 제공
  3. 사용자와 시스템간 인터페이스 제공
  4. 하드웨어와 네트워크 관리 및 제공
  5. 데이터 관리, 데이터와 자원의 공유 기능 제공
  6. 시스템 오류 검사 및 복구
  7. 자원 보호 기능 제공
  8. 입출력 보조 기능 제공

## 프로세스와 스레드?

※ 프로그램 : 파일이 저장 장치에 저장, 메모리에는 올라가 있지 않은 정적인 상태

- 프로세스 : 운영체제로부터 자원을 할당받은 작업의 단위

  : 다른 정의 - 동적 상태의 프로그램

  ![img](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a2620cb7-aae2-406f-9446-6fcde4b84f26/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210618%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210618T075156Z&X-Amz-Expires=86400&X-Amz-Signature=64c3643fb3ddc2b1d50a9250286efe8a8d6aec9a6b92ed2a5291ba152c891fbb&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

  특징

  - 메모리에 올라와 있는 프로그램의 인스턴스(독립적인 개체)

  - 프로세스는 각각 독립된 메모리 영역을 할당받는다.

    **메모리 영역**

    1. Code: 코드 자체를 구성하는 메모리 영역(프로그램 명령)
    2. Data: 전역 변수, 정적 변수, 배열 등(초기화된 데이터)
    3. Stack: 지역 변수, 매개변수, 리턴 값등(임시 메모리 영역)
    4. Heap: 동적 할당 시 사용(new(), mallock() 등)

  - 프로세스 하나당 최소 한개의 스레드(메인 스레드)를 가지고 있다.

  - 각 프로세스는 별도의 주소 공간에서 실행되며, 다른 프로세스의 변수나 자료구조에 접근할 수 없다.

  - 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신 (IPC:inter-process communication) 이용

    ex) 파일, 파이프, 소켓

  **멀티 프로세스**

  : 하나의 응용 프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 한다.

  - 장점
    1. 여러개의 자식 프로세스 중 하나에 문제가 발생하면 해당 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않는다.
  - 단점
    1. 각각의 독립된 메모리 영역을 할당받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수 공유가 안된다.
    2. Context switching 에서의 오버헤드(캐쉬메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모)가 발생한다.

- 스레드 : 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위

  : 프로세스의 한계(자신에게 할당된 메모리에만 접근 제약)를 해결하기 위해 만들어진 개념

  ![img](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/3576d7e8-e8ee-4859-ab7b-6764bd1b61ea/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210618%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210618T075214Z&X-Amz-Expires=86400&X-Amz-Signature=c42e9ebabcc11338dbd04dd96e900feb1ae42b84c02c08db2dbedbe8f4e8969a&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

  특징

  - 프로세스의 자원을 공유한다.
  - 스레드 간 메모리를 공유(code/data/heap)하며 작동한다.
  - 하나의 스레드가 오류나면 전체 프로세스가 종료된다.
  - ex) 알고리즘 coding 느낌

  멀티스레드 특징

  - 장점
    1. Context-Switching할 때 공유하고 있는 메모리만큼의 메모리 자원을 아낄 수 있다.
       - 만약 CPU의 코어 수 보다 더 많은 스레드가 실행되면, 각 코어가 여러 작업을 번갈아 가며 수행하게 되며 이때 각 스레드가 교체될때 스레드간의 context-switching이 발생한다.
       - 이러한 context-switching에 걸리는 시간이 커지면 멀티 스레딩의 효율이 떨어짐.
       - 따라서 단순한 계산은 싱글 스레드로 동작하는 것이 더 효율적일 수 있다.
    2. 스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 스레드간 통신의 부담이 적어서 응답 시간이 빠르다.
  - 단점
    1. 스레드 하나가 프로세스 내 자원을 망쳐버린다면 프로세스가 종료될 수 있다.
    2. 자원을 공유하기 때문에 필연적으로 동기화 문제가 발생할 수밖에 없다.

# CPU

- Central Processing Unit의 줄임말로 중앙 처리 장치라고 한다.
- 컴퓨터와 다른 부품들과 신호를 주고 받으면서 시스템 전체를 제어하는 역할을 한다. (**사용자와 소통하는 역할을 한다**)

※ 이해하기 쉽게 컴퓨터 구매할때 확인하는 정보로 알아보자.

![https://blog.kakaocdn.net/dn/bOpXFQ/btq65dGhRUz/KcIX5wT5o3ksT49HkNiwp1/img.png](https://blog.kakaocdn.net/dn/bOpXFQ/btq65dGhRUz/KcIX5wT5o3ksT49HkNiwp1/img.png)

1. 코어 : CPU 핵심, 이진수 연산, 1개면 싱글코어, 여러개면 멀티코어(듀얼, 쿼드, 헥사...)

> > 코어가 많다(=터널을 많이 뚫었다 = 처리 속도가 빠르다) ↔ 쓰레드가 많다(= 차선이 많다)

1. 클럭 : 초당 명령어를 처리할 수 있는 속도, GHz

> > 클럭이 높다(=제한속도가 높다 = 더 빠르게 일들을 처리할 수 있다)

1. L3 캐시 메모리 : RAM을 거치지 않고 즉각 응답할 수 있도록 저장하는 장소
2. 연산체계 : 32/64bit, 연산 능력, 2의 64승까지 연산 가능

- 구성 요소
  1. 제어 장치(CU): 컴퓨터에 있는 모든 장치들의 동작을 지시하고 제어하는 장치이다. 명령 레지스터에서 읽어들인 명령어를 해독하여 해당하는 장치에게 제어 신호를 보내 정확하게 수행하도록 지시한다.
  2. 연산 장치(ALU): 제어 장치의 명령에 따라 실제로 연산을 수행하는 장치(산술 연산, 논리 연산, 관계 연산 등)
  3. 레지스터: CPU 내부에서 처리할 명령어나 연산의 중간 결과 값 등을 일시적으로 기억하는 임시 기억장소이다.
  4. 버스: CPU, 메모리 I/O 장치 등과 상호 필요한 정보를 교환하기 위해 연결된 공동의 전송선이다.

# 컨택스트 스위칭

> CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정이다. 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태(Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말한다.

- Context: CPU가 해당 프로세스를 실행하기 위한 해당 프로세스의 정보들 (PCB에 저장)

- PCB: 프로세스 식별자, 프로세스 상태, 프로그램 카운터(다음에 실행할 명령어 주소), CPU 레지스터 및 일반 레지스터, CPU 스케쥴링 등등

  ![img](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/04d48687-b3af-4780-b9f0-a8494bbcb909/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210618%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210618T075242Z&X-Amz-Expires=86400&X-Amz-Signature=98abee81d108d72b1908449152e9f859329bc1b34c92a497951c8d2987593f8b&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

- Context Switching 필요 이유: 하나의 작업이 끝날 때까지 기다리면 속도가 너무 느리고 사용하기 불편해서

- 진행 과정:

  1. 대부분의 정보는 레지스터에 저장되고 PCB로 관리한다.
  2. 현재 실행하고 있는 작업의 PCB 정보를 저장한다.
  3. 다음 실행할 작업의 PCB 정보를 읽어 레지스터에 저장하고 CPU가 이전에 진행했던 과정을 연속적으로 수행한다.

- 주의할 점: Context Switching 일 때 해당 CPU는 아무 일을 할 수 없어서 오버헤드가 발생한다.

- Dispatcher는 현재 CPU 데이터는 이전 프로세스의 PCB에 갱신하고, 새로 시작되는 프로세스의 PCB 데이터를 CPU로 복원해준다. Context switching이 발생할 때마다, dispatcher에서 수행하는 작업을 매번 수행해야하며 이 모든 것은 overhead이다.

- 입출력 요청이 왔을 때, CPU 사용 시간이 만료되었을 때, 자식 프로세스를 만들 때, 인터럽트 처리를 기다릴 때 발생한다.

# 스케쥴링

> 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업을 의미.

**목표**

- 공정한 스케쥴링
- 처리량의 극대화(Batch System), 시간보단 처리량이 중요하다
- 응답시간 최소화(Interactive System)
- 균형있는 자원 활용
- 반환시간 예측(Real-time System)

**비선점 스케쥴링**

비선점(nonpreemptive): 프로세스 종료 or I/O 이벤트가 있을때까지 실행 보장(처리시간 예측이 어렵다)

1. FCFS(First Come First Server)
   - 큐에 도착한 순서대로 CPU 할당
   - 실행시간이 짧은게 뒤로 가면 평균 대기시간이 길어진다. (호위 효과)
2. SJF(shortest Job First)
   - 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행
   - FCFS 보다 평균 대기 시간 감소, 짧은 작업에 유리하다.
   - 기아 현상 발생 : 긴 수행시간을 가지는 프로세스는 계속 기다린다.

**선점 스케줄링**

선점(preemptive): 우선순위 높은게 CPU의 사용권을 선점할 수 있는 경우 (운영체제가 컨트롤한다)

1. Priority Scheduling
   - 우선 순위를 부여하여 우선순위가 높은 순서대로 처리
   - 에이징 기법으로 기아 현상은 해결할 수 있다.
2. Round Robin
   - FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 Time Quantum(실행시간의 최소 단위시간)만큼 CPU를 할당 받음
   - 할당 시간(time quantum)이 크면 FCFS와 같게 되고, 작으면 문맥 교환 (Context Switching) 잦아져서 오버헤드 증가
3. Multilevel-Queue(다단계 큐)
   - 작업들을 여러 개의 그룹으로 나누어 여러 개의 큐를 사용하는 기법
   - 우선 순위가 낮은 큐들이 실행 못하는 걸 방지하고자 우선 순위가 높은 큐에는 작은 할당 시간(time quantum)을 주고, 우선 순위가 낮은 큐에는 높은 할당 시간(time quantum)을 준다
4. Multilevel-Feedback-Queue(다단계 피드백 큐)
   - 다단계 큐에서 자신의 할당 시간을 다 채운 프로세스는 밑으로 내려가고 자신의 할당 시간을 다 채우지 못한 프로세스는 원래 큐 그대로 둔다.
   - 짧은 작업에 유리하며 입출력 작업에 우선권을 준다.
5. 대부분의 상용 운영체제는 여러 개의 큐를 사용하고 각 큐마다 다른 스케줄링 방식을 사용한다. 프로세스의 성격에 맞는 스케줄링 방식을 사용하여 최대한 효율을 높일 수 있는 방법을 선택한다.

**CPU 스케줄링 척도**

- Response Time: 작업이 처음 실행되기까지 걸린 시간
- Turnaround Time: 실행 시간과 대기 시간을 모두 합한 시간으로 작업이 완료될 때 까지 걸린 시간
- Waiting Time: 대기 큐에서의 대기시간
- Throughput: 단위시간당 완료된 프로세스 수
- CPU 이용률: CPU를 이용한 수치와 백분율

# 동기화

※ 동기화 이유?

- 덮어씌우기 문제

다중 처리에 의한 문제들이 발생한다. 공유 메모리를 사용하여 문제가 발생한다.

> > **병렬성, 협력성**

나중에 실행된 결과가 나중에 실행된 결과를 덮어씌우게 된다.

- 비일관성

경쟁 상태 : 실행 결과가 실행 과정(순서, 입력 타이밍, 시간)에 의존 하는 상황, 결과가 일정하지 않다.

> > **시스템의 일관성**이 무너지게 된다.

1. 동기화란 공유하는 자원의 일관성을 유지하는 것이다. 하나의 공유된 자원에 접근하려고 할 때 순서를 정하여 데이터의 일관성을 유지시킨다.
   - 데이터의 무결성
     - 일관성 -  원인과 결과가 보장되어 변하지 않는 것을 의미함
     - 정확성 - 중복이나 누락이 없는 상태
2. 임계구역 `Critical section`
   - 공유하는 데이터를 변경하는 코드 영역
   - 임계구역을 해결하기 위한 조건
     - 상호베타(Mutual Exclusion) - 오직 한 스레드만 진입 가능
     - 진행(Progress) - 한 임계구역에 접근하는 스레드를 결정하는 것은 유한시간 내에 이루어져야 함
     - 유한대기(Bounded Waiting) - 임계구역으로 진입하기 위해 대기하는 모든 스레드는 유한 시간 내에 해당 임계구역으로 진입할 수 있어야 함
3. 뮤텍스
   - 자원에 대한 접근을 동기화하기 위해 사용되는 `상호배제` 기술
   - 뮤텍스는 Locking 메커니즘으로 오직 하나의 쓰레드만이 동일한 시점에 뮤텍스를 얻어 임계 영역(Critical Section)에 들어올 수 있다. 그리고 오직 이 쓰레드만이 임계 영역에서 나갈 때 뮤텍스를 해제할 수 있다.
4. 세마포어
   - 운영체제에서 공유 자원에 대한 접속을 제어하기 위해 사용됨
   - 공유자원에 접근할 수 있는 최대 허용치만큼만 동시에 접근 가능.
   - 프로세스의 실행 순서를 원하는 순서로 설정할 수있다.
   - 버퍼가 가득 찼는지 비어있는지 확인하는 무한 반복문인 Busy Waiting을 해결할 수 있다.
   - 세마포어의 카운트가 0보다 작거나 같아져 동기화가 실행된 상황에, 다른 쓰레드가 signal 함수를 호출하면 세마포어의 카운트가 1증가하고, 해당 쓰레드는 락에서 나올 수 있다.
   - Counting Semaphore - 세마포어의 카운트가 양의 정수값을 가지며, 설정한 값만큼 쓰레드를 허용하고 그 이상의 쓰레드가 자원에 접근하면 락이 실행됨
   - Binary Semaphore - 세마포어의 카운트가 1이며 Mutex처럼 사용될 수 있다. (뮤텍스는 절대로 세마포어처럼 사용될 수 없다)
5. 교착상태 `DeadLock`
   - 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태입니다.
   - `상호배제` : 한 프로세스가 자원을 사용하면 다른 프로세스는 이 자원을 사용할 수 없다.
   - `점유대기` : 한 프로세스가 자원을 가지고 있는 상태에서 대기한다
   - `비선점` : 한 프로세스가 자원을 수행하는 중에는 다른 프로세스가 중간에 끼어들 수 없다.
   - `순환대기` : 프로세스가 요구하는 자원의 방향이 원형을 이룬다.
   - 해결방법
     - 예방 : 네 가지 중 최소 한 가지를 만족시키지 않는 것
     - 회피 : 교착상태를 자원 요청에 대한 잘못된 승인으로 판단한다.
     - 무시 : 네가지를 모두 만족하더라도 교착상태가 일어나기 희박하므로 조치하지 않음
     - 발견 : 주기적으로 교착상태가 발생했는지 검사, 오버헤드 발생
     - 회복 : 데드락이 일어날 때까지 기다리고 일어나면 순환하고 찾고 죽일 프로세스를 정하고 죽이던지 롤백
