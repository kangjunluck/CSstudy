### ★ CPU

\- Central Processing Unit의 줄임말로 중앙 처리 장치라고 한다.

\- 컴퓨터와 다른 부품들과 신호를 주고 받으면서 시스템 전체를 제어하는 역할을 한다. (**사용자와 소통하는 역할을 한다**)

 

이해하기 쉽게 컴퓨터 구매할때 확인하는 정보로 알아보자.



![img](https://blog.kakaocdn.net/dn/bOpXFQ/btq65dGhRUz/KcIX5wT5o3ksT49HkNiwp1/img.png)



\1. 코어? : CPU 핵심, 이진수 연산, 1개면 싱글코어, 여러개면 멀티코어(듀얼, 쿼드, 헥사...),

  \>> 코어가 많다(=터널을 많이 뚫었다 = 처리 속도가 빠르다) ↔ 쓰레드가 많다(= 차선이 많다)

\2. 클럭? : 초당 명령어를 처리할 수 있는 속도, GHz

  \>> 클럭이 높다(=제한속도가 높다 = 더 빠르게 일들을 처리할 수 있다)

\3. L3 캐시 메모리 : L = Level을 의미한다, RAM을 거치지 않고 즉각 응답할 수 있도록 저장하는 장소

\4. 연산체계 : 32/64bit, 연산 능력, 2의 64승까지 연산 가능

 

### ★ CPU scheduling

프로세스가 많아지면 프로세스에 순서를 정해줘야한다.

주체 : 운영체제가 기본적으로 한다.

\- 디스패치(dispatch) : 운영체제가 프로세스를 프로세서에 할당하는 작업 (Ready -> Running)

 : CPU scheduling 요소에 반드시 포함된다.

 : 작업 중 context switching이 발생할 수 있다.

CPU 실행 시간 + 입/출력 대기 시간 = 프로세스 실행 시간

\- 스케쥴리 기준 요소

 \1. CPU 사용 : 사용률이 40~60%인 프로세스가 적합하다.

 \2. 처리량 : 단위 시간 당 실행 완료된 프로세스 수

 \3. 총 처리 시간 : 대기 시간 + 프로세스 실행 시간(CPU 실행 시간 + 입출력 대기 시간)

 \4. 최적화된 시간은 평균 측정 시간으로 가정한다.

 

\- 선점 / 비선점 방식

 \1. 선점 방식 : 운영체제가 관리한다, 중간에 다른 프로세스 실행 가능(인터럽트에 의해), 최신 운영체제 스케쥴링 방식

 \2. 비선점 방식 : 프로세스가 끝나면 다음 프로세스가 실행된다.

 

\- FCFS (First Come First Served) - 비선점

 : CPU 요청이 빠른 프로세스를 우선 할당하는 방식 (Queue 사용)

 : 문제 - 호위 효과(Convoy Effect) 발생 : 수행 시간이 긴 프로세스가 점령하게 된다.

 

\- SJF (Shortest Job First) - 비선점

 : 수행 시간이 짧은 프로세스를 우선 할당하는 방식

 : 문제 - 기아 현상 발생 : 긴 수행시간을 가지는 프로세스가 오래 기다리게 된다.

 

\- SRTF (Shortest Remaining Time First) - 선점

 : 남은 수행 시간이 짧은 순서에 따라 할당하는 방식

 : 문제 - 계산 과정이 까다롭다

 

\- RR (Round Robin) - 선점

 : 시간 할당을 위한 할당량이 존재한다( 할당량 만큼만 작업하는 분할 시스템)

 

\- Priority - 선점, 비선점

 : 특정 기준으로 우선순위를 주고 스케쥴링하는 방식

 : 에이징 기법을 통해 기아 현상 해결 가능

 

\- 다단계 큐/ 다단계 피드백 큐

 : 여러 개의 큐를 이용하는 방식

 

### ★ Context Switching

**멀티프로세스 환경**에서 어떤 프로세스를 **실행하고 있는 상태**에서 다른 요청으로 **다른 프로세스가 실행되야 할 때**(우선순위에 의해) 기존 프로세스를 저장하고 다른 프로세스를 **수행하도록 교체하는 작업**을 의미한다.

 \- Context? : 사용자간, 사용자-시스템, 사용자-디바이스간 상호작용에 미치는 프로세스의 현재 상태를 규정하는 정보

 \- Context는 PCB(Process Control Block)에 저장된다. (프로세스 상태, 다음 주소, 레지스터 등)



![img](https://blog.kakaocdn.net/dn/baZicZ/btq67RvGGyf/m0O4m5sgDBqLyboSKVVV61/img.png)



 \- Context Switching 중에는 CPU를 사용하기 때문에 잦으면 오버헤드가 발생한다.

 

인터럽트(다른 프로세스가 실행되도록 인터럽트가 요청함)

 : CPU가 프로그램을 실행하고 있을 때 예외 상황이 발생하여 처리가 필요한 경우 CPU에게 요청하는 것

 \- 우선순위 : 라운드로빈 스케줄링 - 시간단위로 CPU에 할당하는 방식, 누가? OS 스케줄러가 한다.

즉, OS 스케줄러가 Context Switching을 한다.

 

 

### ★ 동기화

\1. 덮어씌우기 문제

다중 처리에 의한 문제들이 발생한다. 공유 메모리를 사용하여 영향을 주게 된다.

\>> **병렬성, 협력성**

나중에 실행된 결과가 나중에 실행된 결과를 덮어씌우게 된다.

 

\2. 비일관성

경쟁 상태 : 실행 결과가 실행 과정(순서, 입력 타이밍, 시간)에 의존 하는 상황, 결과가 일정하지 않다.

먼소리야? >> 

**시스템의 일관성**이 무너지게 된다.

 

임계 영역

 : 위 문제를 해결하기 위해 공유 자원을 선행 작업이 끝날때까지 사용할 수 없도록 하는 '작업 순서 강제 방법'

 : 하나의 작업만 임계 영역에 접근하여 작업하도록 강제한다.

 \- 구성

 \1. 진입 영역 : 임계 영역으로의 접근 허가를 받는 지점

 \2. 임계 영역 : 공유 자원을 사용하는 지점

 \3. 퇴출 영역 : 접근 허가를 반납하는 지점

 \4. 나머지 영역

 \- 요구 조건

 \1. 상호 배제 : 최대한 하나의 작업만 임계 영역에 접근할 수 있어야 한다.

 \2. 진행 : 진입 영역에 있는 작업들만 임계영역에 접근할 기회를 얻을 수 있어야 한다.

 \3. 한정된 대기 : 임계 영역 내 작업이 기아 상태가 되서는 안된다.

 

 \- 구현법

 \1. 세마포를 이용한 해결안

   : **공유 자원의 개수**로 카운팅하여 해결한다. (0이 되면 접근 제한, +,-1을 하며 제어한다)

 \2. 이진 세마포 (뮤텍스 : 상호 배제)

   : locking 메커니즘 활용 (lock을 가졌을 때만 접근 가능, 이후 반환)

 

세마포 vs 뮤텍스

세마포 : 여러개 방, 여러개의 열쇠, 제한된 방 갯수

뮤텍스 : 하나의 방, 하나의 열쇠, 열쇠 건네받아야 입장 가능